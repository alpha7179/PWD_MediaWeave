# System Architecture

> **Media Weave** 시스템 아키텍처 설계 문서
> 
> 본 문서는 프론트엔드, 백엔드, 데이터베이스, 인프라 계층의 구조와 상호작용을 정의합니다.

---

## 1. 아키텍처 개요 (Architecture Overview)

### 1.1. 전체 시스템 구조

```
┌─────────────────────────────────────────────────────────────┐
│                        Client Layer                          │
│  ┌──────────────────────────────────────────────────────┐   │
│  │   React (Vite) - SPA                                 │   │
│  │   - React Flow (트랙 로드맵)                          │   │
│  │   - React-Markdown (프로필 렌더링)                    │   │
│  │   - PapaParse (CSV 파싱)                             │   │
│  └──────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
                            ↕ HTTPS (REST API)
┌─────────────────────────────────────────────────────────────┐
│                      Application Layer                       │
│  ┌──────────────────────────────────────────────────────┐   │
│  │   Node.js + Express.js                               │   │
│  │   - JWT 인증 미들웨어                                 │   │
│  │   - Multer (파일 업로드)                              │   │
│  │   - 비즈니스 로직 (선수과목 검증 등)                   │   │
│  └──────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
                            ↕ SQL / NoSQL
┌─────────────────────────────────────────────────────────────┐
│                       Data Layer                             │
│  ┌─────────────────────┐      ┌─────────────────────────┐   │
│  │  PostgreSQL (RDS)   │      │  MongoDB (Atlas)        │   │
│  │  - Users            │      │  - Curriculums          │   │
│  │  - Courses          │      │  - ActivityLogs         │   │
│  │  - Projects         │      │                         │   │
│  │  - TeamBuilding     │      │                         │   │
│  └─────────────────────┘      └─────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
                            ↕
┌─────────────────────────────────────────────────────────────┐
│                      Storage Layer                           │
│  ┌──────────────────────────────────────────────────────┐   │
│  │   AWS S3                                             │   │
│  │   - 프로젝트 이미지/동영상                            │   │
│  │   - 프로필 사진                                       │   │
│  │   - Markdown 파일                                    │   │
│  └──────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

### 1.2. 아키텍처 패턴

- **Frontend:** SPA (Single Page Application) - React Router를 통한 클라이언트 사이드 라우팅
- **Backend:** RESTful API - Stateless 서버, JWT 기반 인증
- **Database:** Polyglot Persistence - 관계형(PostgreSQL) + 문서형(MongoDB) 하이브리드
- **Deployment:** Cloud-Native - AWS 관리형 서비스 활용

---

## 2. 프론트엔드 아키텍처 (Frontend Architecture)

### 2.1. 기술 스택

| 기술 | 버전 | 용도 |
|------|------|------|
| **React** | 18.x | UI 라이브러리 |
| **Vite** | 5.x | 빌드 도구 (CRA 대비 5배 빠른 HMR) |
| **React Router** | 6.x | 클라이언트 사이드 라우팅 |
| **React Flow** | 11.x | 트랙 로드맵 그래프 시각화 |
| **Axios** | 1.x | HTTP 클라이언트 |
| **React Query** | 5.x | 서버 상태 관리 및 캐싱 |
| **Zustand** | 4.x | 클라이언트 전역 상태 관리 |
| **Tailwind CSS** | 3.x | 유틸리티 기반 스타일링 |
| **PapaParse** | 5.x | CSV 파싱 (성적표 업로드) |
| **React-Markdown** | 9.x | Markdown 렌더링 (프로필) |

### 2.2. 폴더 구조

```
src/
├── assets/              # 정적 파일 (이미지, 폰트)
├── components/          # 재사용 가능한 컴포넌트
│   ├── common/          # 공통 컴포넌트 (Button, Card, Modal)
│   ├── layout/          # 레이아웃 컴포넌트 (Header, Footer, Sidebar)
│   └── features/        # 기능별 컴포넌트
│       ├── roadmap/     # 트랙 로드맵 관련
│       ├── planner/     # 커리큘럼 플래너 관련
│       ├── gallery/     # 프로젝트 갤러리 관련
│       └── teambuilding/# 팀 빌딩 관련
├── pages/               # 페이지 컴포넌트 (라우트별)
│   ├── Home.jsx
│   ├── TrackRoadmap.jsx
│   ├── CurriculumPlanner.jsx
│   ├── ProjectGallery.jsx
│   ├── TeamBuilding.jsx
│   └── Profile.jsx
├── hooks/               # 커스텀 훅
│   ├── useAuth.js       # 인증 관련
│   ├── useCurriculum.js # 커리큘럼 관련
│   └── useProjects.js   # 프로젝트 관련
├── services/            # API 호출 함수
│   ├── api.js           # Axios 인스턴스 설정
│   ├── authService.js
│   ├── curriculumService.js
│   └── projectService.js
├── store/               # Zustand 스토어
│   ├── authStore.js     # 인증 상태
│   └── uiStore.js       # UI 상태 (모달, 토스트)
├── utils/               # 유틸리티 함수
│   ├── csvParser.js     # CSV 파싱 로직
│   ├── validators.js    # 유효성 검사
│   └── formatters.js    # 데이터 포맷팅
├── constants/           # 상수 정의
│   ├── routes.js        # 라우트 경로
│   └── apiEndpoints.js  # API 엔드포인트
├── App.jsx              # 루트 컴포넌트
└── main.jsx             # 엔트리 포인트
```

### 2.3. 상태 관리 전략

#### 서버 상태 (React Query)
- API 데이터 캐싱 및 동기화
- 자동 리페칭 및 백그라운드 업데이트
- 예: 프로젝트 목록, 트랙 로드맵 데이터

```javascript
// 예시: 프로젝트 목록 조회
const { data, isLoading } = useQuery({
  queryKey: ['projects', filters],
  queryFn: () => fetchProjects(filters),
  staleTime: 5 * 60 * 1000, // 5분간 캐시 유지
});
```

#### 클라이언트 상태 (Zustand)
- 인증 정보 (JWT 토큰, 사용자 정보)
- UI 상태 (모달 열림/닫힘, 토스트 메시지)
- 임시 데이터 (드래그 중인 과목 등)

```javascript
// 예시: 인증 스토어
const useAuthStore = create((set) => ({
  user: null,
  token: null,
  login: (user, token) => set({ user, token }),
  logout: () => set({ user: null, token: null }),
}));
```

### 2.4. 라우팅 구조

```javascript
// App.jsx
<Routes>
  <Route path="/" element={<Home />} />
  
  {/* 미디어 커리큘럼 */}
  <Route path="/curriculum">
    <Route path="roadmap" element={<TrackRoadmap />} />
    <Route path="planner" element={<CurriculumPlanner />} />
    <Route path="shared" element={<SharedCurriculums />} />
  </Route>
  
  {/* 커뮤니티 */}
  <Route path="/community">
    <Route path="projects" element={<ProjectGallery />} />
    <Route path="projects/:id" element={<ProjectDetail />} />
    <Route path="team-building" element={<TeamBuilding />} />
  </Route>
  
  {/* 프로필 */}
  <Route path="/profile/:userId" element={<Profile />} />
  
  {/* 인증 */}
  <Route path="/login" element={<Login />} />
  <Route path="/register" element={<Register />} />
</Routes>
```

---

## 3. 백엔드 아키텍처 (Backend Architecture)

### 3.1. 기술 스택

| 기술 | 버전 | 용도 |
|------|------|------|
| **Node.js** | 20.x LTS | 런타임 환경 |
| **Express.js** | 4.x | 웹 프레임워크 |
| **PostgreSQL** | 15.x | 관계형 데이터베이스 |
| **MongoDB** | 7.x | 문서형 데이터베이스 |
| **Sequelize** | 6.x | PostgreSQL ORM |
| **Mongoose** | 8.x | MongoDB ODM |
| **JWT** | 9.x | 인증 토큰 |
| **Bcrypt** | 5.x | 비밀번호 암호화 |
| **Multer** | 1.x | 파일 업로드 |
| **AWS SDK** | 3.x | S3 연동 |

### 3.2. 폴더 구조

```
server/
├── src/
│   ├── config/              # 설정 파일
│   │   ├── database.js      # DB 연결 설정
│   │   ├── aws.js           # AWS S3 설정
│   │   └── jwt.js           # JWT 설정
│   ├── models/              # 데이터 모델
│   │   ├── postgres/        # Sequelize 모델
│   │   │   ├── User.js
│   │   │   ├── Course.js
│   │   │   ├── Project.js
│   │   │   └── TeamBuilding.js
│   │   └── mongodb/         # Mongoose 스키마
│   │       └── Curriculum.js
│   ├── controllers/         # 비즈니스 로직
│   │   ├── authController.js
│   │   ├── curriculumController.js
│   │   ├── projectController.js
│   │   └── teamBuildingController.js
│   ├── routes/              # API 라우트
│   │   ├── auth.js
│   │   ├── curriculum.js
│   │   ├── projects.js
│   │   └── teamBuilding.js
│   ├── middlewares/         # 미들웨어
│   │   ├── auth.js          # JWT 검증
│   │   ├── upload.js        # Multer 설정
│   │   ├── errorHandler.js  # 에러 핸들링
│   │   └── validator.js     # 요청 검증
│   ├── services/            # 서비스 레이어
│   │   ├── prerequisiteService.js  # 선수과목 검증
│   │   ├── s3Service.js     # S3 업로드
│   │   └── csvService.js    # CSV 파싱
│   ├── utils/               # 유틸리티
│   │   ├── logger.js        # 로깅
│   │   └── response.js      # 응답 포맷
│   └── app.js               # Express 앱 설정
├── .env                     # 환경 변수
└── server.js                # 서버 엔트리 포인트
```

### 3.3. API 레이어 구조

```
Request → Middleware → Controller → Service → Model → Database
   ↓          ↓            ↓           ↓        ↓         ↓
 Body     JWT 검증     비즈니스    선수과목   Sequelize  PostgreSQL
Params    파일 업로드    로직       검증      Mongoose   MongoDB
Query     유효성 검사   에러 처리   S3 업로드
```

### 3.4. 인증 플로우

```
1. 회원가입/로그인
   Client → POST /api/auth/login
   Server → Bcrypt 비밀번호 검증
   Server → JWT 토큰 생성 (Access: 15분, Refresh: 7일)
   Server → Response { accessToken, refreshToken, user }

2. 인증이 필요한 API 호출
   Client → GET /api/projects (Header: Authorization: Bearer <token>)
   Server → JWT 미들웨어 검증
   Server → req.user에 사용자 정보 주입
   Controller → 비즈니스 로직 실행

3. 토큰 갱신
   Client → POST /api/auth/refresh (Body: { refreshToken })
   Server → Refresh Token 검증
   Server → 새로운 Access Token 발급
```

---

## 4. 데이터베이스 아키텍처 (Database Architecture)

### 4.1. PostgreSQL (관계형 데이터)

#### 주요 테이블 및 관계

```sql
-- 사용자 관리
Users (user_id, email, password_hash, role, created_at)
Students (student_id, user_id, name, major_id, track_id, grade_level)
Professors (professor_id, user_id, name_ko, name_en, email)

-- 학사 정보
Majors (major_id, name, type, total_credits)
Tracks (track_id, initials, name_ko, name_en)
Courses (course_id, course_code, name_ko, credit, grade_level)

-- 관계 테이블
Course_Prerequisites (course_id, pre_course_id, type)
Course_Tracks (course_id, track_id)
Course_Majors (course_id, major_id, type)

-- 커뮤니티
Projects (project_id, user_id, title, description, track_type, created_at)
Project_TechStacks (project_id, tech_name)
TeamBuilding (post_id, user_id, title, status, deadline)
```

#### 인덱스 전략

```sql
-- 자주 조회되는 컬럼
CREATE INDEX idx_students_major_track ON students(major_id, track_id);
CREATE INDEX idx_courses_code ON courses(course_code);
CREATE INDEX idx_projects_track ON projects(track_type);
CREATE INDEX idx_projects_created ON projects(created_at DESC);

-- 전문 검색 (Full-Text Search)
CREATE INDEX idx_projects_title_gin 
ON projects USING gin(to_tsvector('korean', title));
```

### 4.2. MongoDB (문서형 데이터)

#### Curriculum 스키마

```javascript
{
  _id: ObjectId,
  user_id: String,  // PostgreSQL Users 테이블 참조
  title: String,
  description: String,
  semesters: {
    "1-1": [
      {
        course_id: String,  // PostgreSQL Courses 테이블 참조
        course_code: String,
        course_name: String,
        credit: Number,
        status: String  // "completed", "in-progress", "planned"
      }
    ],
    "1-2": [...],
    // ... 4-2까지
  },
  isPublic: Boolean,
  created_at: Date,
  updated_at: Date
}
```

#### ActivityLog 스키마 (선택사항)

```javascript
{
  _id: ObjectId,
  user_id: String,
  action: String,  // "view_project", "like_project", "search"
  target_id: String,
  metadata: Object,
  timestamp: Date
}
```

### 4.3. 데이터베이스 선택 기준

| 데이터 유형 | 데이터베이스 | 이유 |
|------------|-------------|------|
| **사용자, 과목, 프로젝트** | PostgreSQL | 관계 무결성 필수, JOIN 연산 빈번 |
| **커리큘럼 플랜** | MongoDB | 유연한 스키마 (학기별 과목 배열), 빠른 읽기 |
| **활동 로그** | MongoDB | 대량 쓰기 작업, 스키마 변경 가능성 |

---

## 5. 인프라 아키텍처 (Infrastructure Architecture)

### 5.1. AWS 서비스 구성

```
┌─────────────────────────────────────────────────────────┐
│                    Route 53 (DNS)                        │
│                  mediaweave.ajou.ac.kr                   │
└─────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────┐
│              CloudFront (CDN) + SSL/TLS                  │
│              - 정적 파일 캐싱                             │
│              - HTTPS 강제                                │
└─────────────────────────────────────────────────────────┘
         ↓                                    ↓
┌──────────────────────┐          ┌──────────────────────┐
│   S3 (정적 호스팅)    │          │   EC2 (백엔드 서버)   │
│   - React 빌드 파일   │          │   - Node.js + PM2    │
│   - 이미지/동영상     │          │   - Nginx (리버스)    │
└──────────────────────┘          └──────────────────────┘
                                            ↓
                      ┌─────────────────────────────────┐
                      │   RDS (PostgreSQL)              │
                      │   - Multi-AZ 배포               │
                      │   - 자동 백업 (7일)              │
                      └─────────────────────────────────┘
```

### 5.2. 배포 파이프라인 (CI/CD Pipeline)

#### 5.2.1. CI/CD 워크플로우 다이어그램

```mermaid
graph LR
    A[Git Push] --> B{Branch?}
    B -->|develop| C[Dev Pipeline]
    B -->|staging| D[Staging Pipeline]
    B -->|main| E[Production Pipeline]
    
    C --> C1[Install Dependencies]
    C1 --> C2[Run Tests]
    C2 --> C3[Build]
    C3 --> C4[Deploy to Dev]
    C4 --> C5[Health Check]
    
    D --> D1[Install Dependencies]
    D1 --> D2[Run Tests]
    D2 --> D3[Build]
    D3 --> D4[Deploy to Staging]
    D4 --> D5[Integration Tests]
    D5 --> D6[Manual Approval]
    
    E --> E1[Install Dependencies]
    E1 --> E2[Run Tests]
    E2 --> E3[Security Scan]
    E3 --> E4[Build]
    E4 --> E5[Deploy to Production]
    E5 --> E6[Health Check]
    E6 --> E7[Smoke Tests]
    E7 --> E8{Success?}
    E8 -->|No| E9[Auto Rollback]
    E8 -->|Yes| E10[Complete]
```

#### 5.2.2. GitHub Actions 워크플로우

**Frontend 배포 (`.github/workflows/frontend-deploy.yml`)**

```yaml
name: Frontend Deploy

on:
  push:
    branches: [develop, staging, main]
    paths:
      - 'client/**'
      - '.github/workflows/frontend-deploy.yml'

env:
  NODE_VERSION: '20.x'

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: client/package-lock.json
      
      - name: Install dependencies
        working-directory: ./client
        run: npm ci
      
      - name: Run linter
        working-directory: ./client
        run: npm run lint
      
      - name: Run tests
        working-directory: ./client
        run: npm run test:ci
      
      - name: Build
        working-directory: ./client
        run: npm run build
        env:
          VITE_API_URL: ${{ secrets[format('VITE_API_URL_{0}', github.ref_name)] }}
      
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build
          path: client/dist
          retention-days: 7

  deploy:
    needs: test
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.ref_name }}
      url: ${{ steps.deploy.outputs.url }}
    
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: frontend-build
          path: dist
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-northeast-2
      
      - name: Deploy to S3
        id: deploy
        run: |
          BUCKET_NAME="${{ secrets[format('S3_BUCKET_{0}', github.ref_name)] }}"
          aws s3 sync dist/ s3://${BUCKET_NAME} --delete --cache-control max-age=31536000
          aws s3 cp s3://${BUCKET_NAME}/index.html s3://${BUCKET_NAME}/index.html --metadata-directive REPLACE --cache-control max-age=0,no-cache,no-store,must-revalidate
          echo "url=https://${BUCKET_NAME}.s3-website.ap-northeast-2.amazonaws.com" >> $GITHUB_OUTPUT
      
      - name: Invalidate CloudFront cache
        if: github.ref == 'refs/heads/main'
        run: |
          aws cloudfront create-invalidation \
            --distribution-id ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }} \
            --paths "/*"
      
      - name: Health check
        run: |
          URL="${{ steps.deploy.outputs.url }}"
          for i in {1..5}; do
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" $URL)
            if [ $STATUS -eq 200 ]; then
              echo "Health check passed"
              exit 0
            fi
            echo "Attempt $i failed, retrying..."
            sleep 10
          done
          echo "Health check failed"
          exit 1
```

**Backend 배포 (`.github/workflows/backend-deploy.yml`)**

```yaml
name: Backend Deploy

on:
  push:
    branches: [develop, staging, main]
    paths:
      - 'server/**'
      - '.github/workflows/backend-deploy.yml'

env:
  NODE_VERSION: '20.x'

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_DB: test_db
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_password
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      
      mongodb:
        image: mongo:7
        ports:
          - 27017:27017
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: server/package-lock.json
      
      - name: Install dependencies
        working-directory: ./server
        run: npm ci
      
      - name: Run linter
        working-directory: ./server
        run: npm run lint
      
      - name: Run tests
        working-directory: ./server
        run: npm run test:ci
        env:
          DB_HOST: localhost
          DB_PORT: 5432
          DB_NAME: test_db
          DB_USER: test_user
          DB_PASSWORD: test_password
          MONGO_URI: mongodb://localhost:27017/test_db
      
      - name: Security scan
        if: github.ref == 'refs/heads/main'
        working-directory: ./server
        run: npm audit --audit-level=high

  deploy:
    needs: test
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.ref_name }}
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Deploy to EC2
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets[format('EC2_HOST_{0}', github.ref_name)] }}
          username: ubuntu
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            cd /home/ubuntu/mediaweave-api
            git pull origin ${{ github.ref_name }}
            npm ci --production
            pm2 reload ecosystem.config.js --env ${{ github.ref_name }}
            
            # Health check
            sleep 5
            for i in {1..10}; do
              STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000/health)
              if [ $STATUS -eq 200 ]; then
                echo "Health check passed"
                exit 0
              fi
              echo "Attempt $i failed, retrying..."
              sleep 3
            done
            
            echo "Health check failed, rolling back"
            pm2 reload ecosystem.config.js --env ${{ github.ref_name }}
            exit 1
      
      - name: Run smoke tests
        if: github.ref == 'refs/heads/main'
        run: |
          API_URL="${{ secrets.API_URL_PRODUCTION }}"
          
          # Test health endpoint
          curl -f ${API_URL}/health || exit 1
          
          # Test auth endpoint
          curl -f ${API_URL}/api/auth/status || exit 1
          
          echo "Smoke tests passed"
```

#### 5.2.3. 환경별 설정

**Development 환경**

```bash
# 목적: 개발자 로컬 테스트 및 기능 검증
# 배포 주기: 매 커밋 (자동)
# 데이터: 테스트 데이터

# Frontend
VITE_API_URL=http://localhost:3000
VITE_ENV=development

# Backend
NODE_ENV=development
PORT=3000
DB_HOST=localhost
DB_NAME=mediaweave_dev
MONGO_URI=mongodb://localhost:27017/mediaweave_dev
LOG_LEVEL=debug
CORS_ORIGIN=http://localhost:5173
```

**Staging 환경**

```bash
# 목적: QA 테스트 및 프로덕션 배포 전 검증
# 배포 주기: 주 1-2회 (수동 승인 필요)
# 데이터: 프로덕션 유사 데이터

# Frontend
VITE_API_URL=https://api-staging.mediaweave.ajou.ac.kr
VITE_ENV=staging

# Backend
NODE_ENV=staging
PORT=3000
DB_HOST=mediaweave-staging.xxxxx.ap-northeast-2.rds.amazonaws.com
DB_NAME=mediaweave_staging
MONGO_URI=mongodb+srv://user:***@cluster-staging.mongodb.net/mediaweave
LOG_LEVEL=info
CORS_ORIGIN=https://staging.mediaweave.ajou.ac.kr
RATE_LIMIT_MAX=200
```

**Production 환경**

```bash
# 목적: 실제 사용자 서비스
# 배포 주기: 2주 1회 (수동 승인 + 자동 롤백)
# 데이터: 실제 사용자 데이터

# Frontend
VITE_API_URL=https://api.mediaweave.ajou.ac.kr
VITE_ENV=production
VITE_SENTRY_DSN=https://***@sentry.io/***

# Backend
NODE_ENV=production
PORT=3000
DB_HOST=mediaweave-prod.xxxxx.ap-northeast-2.rds.amazonaws.com
DB_NAME=mediaweave_production
MONGO_URI=mongodb+srv://user:***@cluster-prod.mongodb.net/mediaweave
LOG_LEVEL=warn
CORS_ORIGIN=https://mediaweave.ajou.ac.kr
RATE_LIMIT_MAX=100
ENABLE_MONITORING=true
SENTRY_DSN=https://***@sentry.io/***
```

**환경별 인프라 구성**

| 리소스 | Development | Staging | Production |
|--------|-------------|---------|------------|
| **Frontend** | 로컬 (Vite Dev Server) | S3 + CloudFront | S3 + CloudFront |
| **Backend** | 로컬 (Node.js) | EC2 t3.small (1대) | EC2 t3.medium (2대 + ALB) |
| **PostgreSQL** | 로컬 | RDS db.t3.micro | RDS db.t3.small (Multi-AZ) |
| **MongoDB** | 로컬 | Atlas M0 (Free) | Atlas M10 |
| **Redis** | - | - | ElastiCache t3.micro |
| **백업** | - | 일 1회 (7일 보관) | 일 1회 (30일 보관) |

#### 5.2.4. PM2 Ecosystem 설정

**`ecosystem.config.js`**

```javascript
module.exports = {
  apps: [
    {
      name: 'mediaweave-api',
      script: './src/server.js',
      instances: 'max',
      exec_mode: 'cluster',
      
      // 환경별 설정
      env_development: {
        NODE_ENV: 'development',
        PORT: 3000,
        watch: true,
        ignore_watch: ['node_modules', 'logs'],
      },
      
      env_staging: {
        NODE_ENV: 'staging',
        PORT: 3000,
        instances: 2,
        max_memory_restart: '500M',
      },
      
      env_production: {
        NODE_ENV: 'production',
        PORT: 3000,
        instances: 4,
        max_memory_restart: '1G',
        error_file: './logs/error.log',
        out_file: './logs/out.log',
        log_date_format: 'YYYY-MM-DD HH:mm:ss Z',
        merge_logs: true,
      },
      
      // 자동 재시작 설정
      autorestart: true,
      max_restarts: 10,
      min_uptime: '10s',
      
      // Health check
      listen_timeout: 10000,
      kill_timeout: 5000,
    },
  ],
};
```

#### 5.2.5. 롤백 전략

**자동 롤백 조건**

```javascript
// Health check 실패 시 자동 롤백
const healthCheck = async () => {
  const checks = [
    { name: 'Database', fn: checkDatabase },
    { name: 'MongoDB', fn: checkMongoDB },
    { name: 'S3', fn: checkS3 },
    { name: 'API', fn: checkAPI },
  ];
  
  for (const check of checks) {
    try {
      await check.fn();
    } catch (error) {
      logger.error(`Health check failed: ${check.name}`, error);
      return false;
    }
  }
  
  return true;
};

// 배포 후 5분간 에러율 모니터링
const monitorErrorRate = async () => {
  const errorRate = await getErrorRateFromCloudWatch();
  const threshold = 5; // 5% 이상 에러 시 롤백
  
  if (errorRate > threshold) {
    logger.error(`Error rate ${errorRate}% exceeds threshold ${threshold}%`);
    return false;
  }
  
  return true;
};
```

**수동 롤백 절차**

```bash
# 1. 이전 버전 확인
git log --oneline -10

# 2. Frontend 롤백 (S3)
# 이전 빌드 파일을 S3에 재업로드
aws s3 sync ./backup/build-v1.2.3/ s3://mediaweave-frontend --delete
aws cloudfront create-invalidation --distribution-id E1234567890ABC --paths "/*"

# 3. Backend 롤백 (PM2)
cd /home/ubuntu/mediaweave-api
git checkout v1.2.3
npm ci --production
pm2 reload ecosystem.config.js --env production

# 4. Database 롤백 (필요 시)
# RDS 스냅샷에서 복원
aws rds restore-db-instance-from-db-snapshot \
  --db-instance-identifier mediaweave-prod-rollback \
  --db-snapshot-identifier mediaweave-prod-snapshot-20240101

# 5. 롤백 검증
curl https://api.mediaweave.ajou.ac.kr/health
curl https://mediaweave.ajou.ac.kr
```

**Blue-Green 배포 (향후 도입)**

```mermaid
graph LR
    A[Load Balancer] --> B[Blue Environment<br/>Current Version]
    A -.-> C[Green Environment<br/>New Version]
    
    D[Deploy to Green] --> E[Run Tests on Green]
    E --> F{Tests Pass?}
    F -->|Yes| G[Switch Traffic to Green]
    F -->|No| H[Keep Blue Active]
    
    G --> I[Blue becomes Standby]
    I --> J[Next deployment uses Blue]
```

**롤백 시간 목표 (RTO)**

| 환경 | 목표 시간 | 방법 |
|------|----------|------|
| **Development** | 즉시 | Git revert + 재배포 |
| **Staging** | 10분 이내 | PM2 reload + S3 이전 버전 |
| **Production** | 5분 이내 | 자동 롤백 스크립트 실행 |

**배포 체크리스트**

- [ ] 모든 테스트 통과 (Unit, Integration)
- [ ] 보안 스캔 완료 (npm audit)
- [ ] 데이터베이스 마이그레이션 검증
- [ ] 환경 변수 설정 확인
- [ ] 백업 생성 (DB 스냅샷)
- [ ] 롤백 계획 수립
- [ ] 모니터링 대시보드 준비
- [ ] 배포 공지 (Staging/Production)
- [ ] Health check 통과
- [ ] Smoke test 통과

### 5.3. 환경 변수 관리

```bash
# .env (서버)
NODE_ENV=production
PORT=3000

# PostgreSQL
DB_HOST=mediaweave-db.xxxxx.ap-northeast-2.rds.amazonaws.com
DB_PORT=5432
DB_NAME=mediaweave
DB_USER=admin
DB_PASSWORD=***

# MongoDB
MONGO_URI=mongodb+srv://user:***@cluster.mongodb.net/mediaweave

# JWT
JWT_SECRET=***
JWT_ACCESS_EXPIRY=15m
JWT_REFRESH_EXPIRY=7d

# AWS S3
AWS_REGION=ap-northeast-2
AWS_S3_BUCKET=mediaweave-uploads
AWS_ACCESS_KEY_ID=***
AWS_SECRET_ACCESS_KEY=***
```

---

## 6. 보안 아키텍처 (Security Architecture)

### 6.1. 인증 및 권한

- **JWT 기반 인증:** Stateless, 확장 가능
- **Role-Based Access Control (RBAC):** Admin, Student, Professor
- **Refresh Token 전략:** Access Token 탈취 시 피해 최소화

### 6.2. 데이터 보안

- **비밀번호 암호화:** Bcrypt (Salt Rounds: 10)
- **HTTPS 통신:** AWS Certificate Manager를 통한 SSL/TLS
- **SQL Injection 방지:** Sequelize ORM 사용 (Parameterized Query)
- **XSS 방지:** React의 기본 이스케이핑 + DOMPurify (Markdown 렌더링 시)

### 6.3. 파일 업로드 보안

```javascript
// Multer 설정
const upload = multer({
  limits: { fileSize: 10 * 1024 * 1024 }, // 10MB
  fileFilter: (req, file, cb) => {
    const allowedTypes = ['image/jpeg', 'image/png', 'image/webp'];
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('Invalid file type'));
    }
  }
});
```

### 6.4. Rate Limiting

```javascript
const rateLimit = require('express-rate-limit');

const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15분
  max: 100, // 최대 100 요청
  message: 'Too many requests from this IP'
});

app.use('/api/', limiter);
```

---

## 7. 성능 최적화 (Performance Optimization)

### 7.1. 캐싱 전략

#### 7.1.1. Redis 캐싱 아키텍처

```
┌─────────────┐
│   Client    │
└──────┬──────┘
       │ HTTP Request
       ↓
┌─────────────────────────────────────┐
│         API Server (Express)        │
│  ┌──────────────────────────────┐   │
│  │  1. Check Redis Cache        │   │
│  │     ↓ Cache Hit → Return     │   │
│  │     ↓ Cache Miss             │   │
│  │  2. Query Database           │   │
│  │  3. Store in Redis (TTL)     │   │
│  │  4. Return Response          │   │
│  └──────────────────────────────┘   │
└─────────────────────────────────────┘
       ↓                    ↓
┌─────────────┐      ┌─────────────┐
│    Redis    │      │  PostgreSQL │
│ ElastiCache │      │     RDS     │
└─────────────┘      └─────────────┘
```

#### 7.1.2. Redis 캐시 전략 상세

**캐시 대상 데이터**

| 데이터 유형 | TTL | 무효화 조건 | 예상 적중률 |
|------------|-----|------------|-----------|
| **트랙 로드맵** | 24시간 | 과목 정보 변경 시 | 95% |
| **과목 목록** | 12시간 | 학기 시작 시 | 90% |
| **사용자 프로필** | 1시간 | 프로필 수정 시 | 85% |
| **프로젝트 목록** | 5분 | 새 프로젝트 등록 시 | 70% |
| **검색 결과** | 10분 | - | 60% |

**Redis 설정**

```javascript
// redis.config.js
const redis = require('redis');

const redisClient = redis.createClient({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT || 6379,
  password: process.env.REDIS_PASSWORD,
  
  // 연결 풀 설정
  socket: {
    connectTimeout: 5000,
    keepAlive: 5000,
  },
  
  // 재연결 전략
  retry_strategy: (options) => {
    if (options.error && options.error.code === 'ECONNREFUSED') {
      return new Error('Redis server refused connection');
    }
    if (options.total_retry_time > 1000 * 60 * 60) {
      return new Error('Redis retry time exhausted');
    }
    if (options.attempt > 10) {
      return undefined; // 재연결 중단
    }
    return Math.min(options.attempt * 100, 3000);
  },
});

module.exports = redisClient;
```

**캐시 미들웨어 구현**

```javascript
// middleware/cache.js
const cacheMiddleware = (duration) => {
  return async (req, res, next) => {
    // GET 요청만 캐싱
    if (req.method !== 'GET') {
      return next();
    }
    
    const key = `cache:${req.originalUrl}`;
    
    try {
      // 캐시 확인
      const cachedData = await redisClient.get(key);
      
      if (cachedData) {
        logger.info('Cache hit', { key, url: req.originalUrl });
        return res.json(JSON.parse(cachedData));
      }
      
      // 캐시 미스 - 응답 저장
      const originalJson = res.json.bind(res);
      res.json = (data) => {
        redisClient.setex(key, duration, JSON.stringify(data));
        logger.info('Cache set', { key, ttl: duration });
        return originalJson(data);
      };
      
      next();
    } catch (error) {
      logger.error('Cache error', { error: error.message });
      next(); // 캐시 실패 시 정상 처리 계속
    }
  };
};

// 사용 예시
app.get('/api/tracks', cacheMiddleware(86400), trackController.getAll);
app.get('/api/courses', cacheMiddleware(43200), courseController.getAll);
app.get('/api/projects', cacheMiddleware(300), projectController.getAll);
```

**캐시 무효화 전략**

```javascript
// services/cacheInvalidation.js
const invalidateCache = async (pattern) => {
  try {
    const keys = await redisClient.keys(pattern);
    if (keys.length > 0) {
      await redisClient.del(...keys);
      logger.info('Cache invalidated', { pattern, count: keys.length });
    }
  } catch (error) {
    logger.error('Cache invalidation failed', { error: error.message });
  }
};

// 사용 예시
// 프로젝트 생성 시 프로젝트 목록 캐시 무효화
app.post('/api/projects', async (req, res) => {
  const project = await projectService.create(req.body);
  await invalidateCache('cache:/api/projects*');
  res.status(201).json(project);
});

// 과목 정보 수정 시 트랙 로드맵 캐시 무효화
app.put('/api/courses/:id', async (req, res) => {
  const course = await courseService.update(req.params.id, req.body);
  await invalidateCache('cache:/api/tracks*');
  await invalidateCache('cache:/api/courses*');
  res.json(course);
});
```

#### 7.1.3. CDN 캐싱 (CloudFront)

**캐시 동작 설정**

```json
{
  "CacheBehaviors": [
    {
      "PathPattern": "/assets/*",
      "TargetOriginId": "S3-mediaweave-frontend",
      "ViewerProtocolPolicy": "redirect-to-https",
      "CachePolicyId": "658327ea-f89d-4fab-a63d-7e88639e58f6",
      "Compress": true,
      "DefaultTTL": 31536000,
      "MaxTTL": 31536000,
      "MinTTL": 31536000
    },
    {
      "PathPattern": "/images/*",
      "TargetOriginId": "S3-mediaweave-uploads",
      "ViewerProtocolPolicy": "redirect-to-https",
      "CachePolicyId": "658327ea-f89d-4fab-a63d-7e88639e58f6",
      "Compress": true,
      "DefaultTTL": 86400,
      "MaxTTL": 31536000,
      "MinTTL": 0
    },
    {
      "PathPattern": "/api/*",
      "TargetOriginId": "ALB-mediaweave-api",
      "ViewerProtocolPolicy": "https-only",
      "CachePolicyId": "4135ea2d-6df8-44a3-9df3-4b5a84be39ad",
      "AllowedMethods": ["GET", "HEAD", "OPTIONS", "PUT", "POST", "PATCH", "DELETE"],
      "CachedMethods": ["GET", "HEAD", "OPTIONS"],
      "DefaultTTL": 0,
      "MaxTTL": 0,
      "MinTTL": 0
    }
  ]
}
```

**Cache-Control 헤더 설정**

```javascript
// Express 미들웨어
app.use('/assets', express.static('public/assets', {
  maxAge: '1y',
  immutable: true,
  setHeaders: (res, path) => {
    if (path.endsWith('.html')) {
      res.setHeader('Cache-Control', 'no-cache');
    }
  },
}));

// S3 업로드 시 메타데이터 설정
const uploadToS3 = async (file, key) => {
  const params = {
    Bucket: process.env.AWS_S3_BUCKET,
    Key: key,
    Body: file.buffer,
    ContentType: file.mimetype,
    CacheControl: 'max-age=31536000, immutable',
  };
  
  return s3.upload(params).promise();
};
```

#### 7.1.4. 브라우저 캐싱

```javascript
// React Query 설정
import { QueryClient } from '@tanstack/react-query';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5분간 fresh 상태 유지
      cacheTime: 10 * 60 * 1000, // 10분간 캐시 보관
      refetchOnWindowFocus: false,
      refetchOnReconnect: true,
      retry: 1,
    },
  },
});

// 데이터별 캐싱 전략
const { data: tracks } = useQuery({
  queryKey: ['tracks'],
  queryFn: fetchTracks,
  staleTime: 24 * 60 * 60 * 1000, // 24시간 (거의 변경 안 됨)
});

const { data: projects } = useQuery({
  queryKey: ['projects', filters],
  queryFn: () => fetchProjects(filters),
  staleTime: 5 * 60 * 1000, // 5분 (자주 변경됨)
});
```

### 7.2. 데이터베이스 쿼리 최적화

#### 7.2.1. 인덱스 전략

**PostgreSQL 인덱스 정의**

```sql
-- 복합 인덱스 (자주 함께 조회되는 컬럼)
CREATE INDEX idx_students_major_track_grade 
ON students(major_id, track_id, grade_level);

-- 부분 인덱스 (조건부 인덱스)
CREATE INDEX idx_projects_published 
ON projects(created_at DESC) 
WHERE status = 'published';

-- 커버링 인덱스 (쿼리에 필요한 모든 컬럼 포함)
CREATE INDEX idx_courses_search 
ON courses(course_code, name_ko, credit, grade_level);

-- Full-Text Search 인덱스
CREATE INDEX idx_projects_title_search 
ON projects USING gin(to_tsvector('korean', title || ' ' || description));

-- JSON 컬럼 인덱스
CREATE INDEX idx_projects_tech_stacks 
ON projects USING gin(tech_stacks);
```

**인덱스 사용 확인**

```sql
-- 쿼리 실행 계획 확인
EXPLAIN ANALYZE
SELECT * FROM projects 
WHERE track_type = 'frontend' 
  AND status = 'published'
ORDER BY created_at DESC
LIMIT 20;

-- 인덱스 사용률 확인
SELECT 
  schemaname,
  tablename,
  indexname,
  idx_scan as index_scans,
  idx_tup_read as tuples_read,
  idx_tup_fetch as tuples_fetched
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY idx_scan DESC;

-- 미사용 인덱스 찾기
SELECT 
  schemaname,
  tablename,
  indexname
FROM pg_stat_user_indexes
WHERE idx_scan = 0
  AND indexrelname NOT LIKE '%_pkey';
```

#### 7.2.2. N+1 문제 해결

**문제 상황**

```javascript
// ❌ N+1 문제 발생
const projects = await Project.findAll();
for (const project of projects) {
  project.user = await User.findByPk(project.user_id); // N번 쿼리
  project.techStacks = await TechStack.findAll({ 
    where: { project_id: project.id } 
  }); // N번 쿼리
}
```

**해결 방법 1: Eager Loading**

```javascript
// ✅ Sequelize include 사용
const projects = await Project.findAll({
  include: [
    {
      model: User,
      as: 'user',
      attributes: ['id', 'name', 'email'],
    },
    {
      model: TechStack,
      as: 'techStacks',
      attributes: ['name'],
    },
  ],
  limit: 20,
  order: [['created_at', 'DESC']],
});

// 생성되는 SQL (JOIN 사용)
/*
SELECT 
  projects.*,
  user.id, user.name, user.email,
  tech_stacks.name
FROM projects
LEFT JOIN users AS user ON projects.user_id = user.id
LEFT JOIN tech_stacks ON projects.id = tech_stacks.project_id
ORDER BY projects.created_at DESC
LIMIT 20;
*/
```

**해결 방법 2: DataLoader (GraphQL)**

```javascript
const DataLoader = require('dataloader');

// 배치 로딩 함수
const batchLoadUsers = async (userIds) => {
  const users = await User.findAll({
    where: { id: userIds },
  });
  
  const userMap = new Map(users.map(u => [u.id, u]));
  return userIds.map(id => userMap.get(id));
};

const userLoader = new DataLoader(batchLoadUsers);

// 사용
const projects = await Project.findAll();
const projectsWithUsers = await Promise.all(
  projects.map(async (project) => ({
    ...project.toJSON(),
    user: await userLoader.load(project.user_id),
  }))
);
```

#### 7.2.3. 쿼리 최적화 기법

**페이지네이션 최적화**

```javascript
// ❌ OFFSET 방식 (느림 - 큰 OFFSET에서 성능 저하)
const projects = await Project.findAll({
  offset: page * limit,
  limit: limit,
  order: [['created_at', 'DESC']],
});

// ✅ Cursor 방식 (빠름 - 인덱스 활용)
const projects = await Project.findAll({
  where: {
    created_at: { [Op.lt]: cursor }, // cursor 이전 데이터
  },
  limit: limit,
  order: [['created_at', 'DESC']],
});
```

**집계 쿼리 최적화**

```javascript
// ❌ 애플리케이션 레벨 집계 (느림)
const projects = await Project.findAll();
const totalCredits = projects.reduce((sum, p) => sum + p.credits, 0);

// ✅ 데이터베이스 레벨 집계 (빠름)
const result = await Project.findOne({
  attributes: [
    [sequelize.fn('SUM', sequelize.col('credits')), 'totalCredits'],
    [sequelize.fn('COUNT', sequelize.col('id')), 'projectCount'],
  ],
});
```

**부분 컬럼 조회**

```javascript
// ❌ 모든 컬럼 조회 (불필요한 데이터 전송)
const projects = await Project.findAll();

// ✅ 필요한 컬럼만 조회
const projects = await Project.findAll({
  attributes: ['id', 'title', 'thumbnail', 'created_at'],
});
```

#### 7.2.4. Connection Pool 설정

```javascript
// Sequelize 연결 풀 설정
const sequelize = new Sequelize(database, username, password, {
  host: host,
  dialect: 'postgres',
  
  pool: {
    max: 20,          // 최대 연결 수
    min: 5,           // 최소 연결 수
    acquire: 30000,   // 연결 획득 타임아웃 (30초)
    idle: 10000,      // 유휴 연결 해제 시간 (10초)
  },
  
  // 쿼리 로깅 (개발 환경에서만)
  logging: process.env.NODE_ENV === 'development' ? console.log : false,
  
  // 쿼리 타임아웃
  dialectOptions: {
    statement_timeout: 10000, // 10초
  },
});

// MongoDB 연결 풀 설정
mongoose.connect(process.env.MONGO_URI, {
  maxPoolSize: 10,
  minPoolSize: 2,
  socketTimeoutMS: 45000,
  serverSelectionTimeoutMS: 5000,
});
```

### 7.3. 이미지 최적화

#### 7.3.1. WebP 변환 및 리사이징

```javascript
// Multer + Sharp를 사용한 이미지 처리
const multer = require('multer');
const sharp = require('sharp');

const upload = multer({
  storage: multer.memoryStorage(),
  limits: { fileSize: 10 * 1024 * 1024 }, // 10MB
  fileFilter: (req, file, cb) => {
    const allowedTypes = ['image/jpeg', 'image/png', 'image/webp'];
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('Invalid file type'));
    }
  },
});

const processImage = async (buffer) => {
  // 여러 크기로 리사이징 + WebP 변환
  const sizes = [
    { name: 'thumbnail', width: 300, height: 200 },
    { name: 'medium', width: 800, height: 600 },
    { name: 'large', width: 1920, height: 1080 },
  ];
  
  const processed = await Promise.all(
    sizes.map(async (size) => {
      const webpBuffer = await sharp(buffer)
        .resize(size.width, size.height, {
          fit: 'cover',
          position: 'center',
        })
        .webp({ quality: 80 })
        .toBuffer();
      
      return { name: size.name, buffer: webpBuffer };
    })
  );
  
  return processed;
};

// 업로드 엔드포인트
app.post('/api/projects/upload', upload.single('image'), async (req, res) => {
  try {
    const processed = await processImage(req.file.buffer);
    
    // S3에 업로드
    const urls = await Promise.all(
      processed.map(async ({ name, buffer }) => {
        const key = `projects/${Date.now()}-${name}.webp`;
        await uploadToS3(buffer, key);
        return { size: name, url: `https://cdn.mediaweave.ajou.ac.kr/${key}` };
      })
    );
    
    res.json({ urls });
  } catch (error) {
    logger.error('Image upload failed', { error: error.message });
    res.status(500).json({ error: 'Image upload failed' });
  }
});
```

#### 7.3.2. Lazy Loading 구현

```javascript
// React 컴포넌트
import { useState, useEffect, useRef } from 'react';

const LazyImage = ({ src, alt, placeholder }) => {
  const [isLoaded, setIsLoaded] = useState(false);
  const [isInView, setIsInView] = useState(false);
  const imgRef = useRef();
  
  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setIsInView(true);
          observer.disconnect();
        }
      },
      { rootMargin: '100px' } // 뷰포트 100px 전에 로딩 시작
    );
    
    if (imgRef.current) {
      observer.observe(imgRef.current);
    }
    
    return () => observer.disconnect();
  }, []);
  
  return (
    <div ref={imgRef} className="relative">
      {!isLoaded && (
        <div className="absolute inset-0 bg-gray-200 animate-pulse" />
      )}
      {isInView && (
        <img
          src={src}
          alt={alt}
          loading="lazy"
          onLoad={() => setIsLoaded(true)}
          className={`transition-opacity duration-300 ${
            isLoaded ? 'opacity-100' : 'opacity-0'
          }`}
        />
      )}
    </div>
  );
};
```

#### 7.3.3. Responsive Images

```javascript
// srcset을 사용한 반응형 이미지
const ResponsiveImage = ({ baseUrl, alt }) => {
  return (
    <picture>
      <source
        type="image/webp"
        srcSet={`
          ${baseUrl}-thumbnail.webp 300w,
          ${baseUrl}-medium.webp 800w,
          ${baseUrl}-large.webp 1920w
        `}
        sizes="(max-width: 640px) 300px, (max-width: 1024px) 800px, 1920px"
      />
      <img
        src={`${baseUrl}-medium.webp`}
        alt={alt}
        loading="lazy"
        decoding="async"
      />
    </picture>
  );
};
```

### 7.4. Frontend 성능 최적화

#### 7.4.1. Code Splitting

```javascript
// React.lazy를 사용한 라우트 기반 코드 분할
import { lazy, Suspense } from 'react';
import { Routes, Route } from 'react-router-dom';

const Home = lazy(() => import('./pages/Home'));
const TrackRoadmap = lazy(() => import('./pages/TrackRoadmap'));
const CurriculumPlanner = lazy(() => import('./pages/CurriculumPlanner'));
const ProjectGallery = lazy(() => import('./pages/ProjectGallery'));

function App() {
  return (
    <Suspense fallback={<LoadingSpinner />}>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/curriculum/roadmap" element={<TrackRoadmap />} />
        <Route path="/curriculum/planner" element={<CurriculumPlanner />} />
        <Route path="/community/projects" element={<ProjectGallery />} />
      </Routes>
    </Suspense>
  );
}

// Vite 빌드 결과
/*
dist/
├── index.html
├── assets/
│   ├── index-abc123.js (메인 번들, ~50KB)
│   ├── Home-def456.js (~30KB)
│   ├── TrackRoadmap-ghi789.js (~80KB)
│   ├── CurriculumPlanner-jkl012.js (~120KB)
│   └── ProjectGallery-mno345.js (~60KB)
*/
```

#### 7.4.2. 번들 크기 최적화

```javascript
// vite.config.js
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import { visualizer } from 'rollup-plugin-visualizer';

export default defineConfig({
  plugins: [
    react(),
    visualizer({ open: true }), // 번들 분석
  ],
  
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          // 벤더 라이브러리 분리
          'react-vendor': ['react', 'react-dom', 'react-router-dom'],
          'ui-vendor': ['@headlessui/react', '@heroicons/react'],
          'data-vendor': ['@tanstack/react-query', 'axios'],
          'flow-vendor': ['reactflow'],
        },
      },
    },
    
    // 압축 설정
    minify: 'terser',
    terserOptions: {
      compress: {
        drop_console: true, // console.log 제거
        drop_debugger: true,
      },
    },
    
    // 청크 크기 경고 임계값
    chunkSizeWarningLimit: 500, // 500KB
  },
});
```

#### 7.4.3. Debouncing & Throttling

```javascript
// 검색 입력 디바운싱
import { useState, useCallback } from 'react';
import { debounce } from 'lodash';

const SearchBar = () => {
  const [query, setQuery] = useState('');
  
  const debouncedSearch = useCallback(
    debounce((value) => {
      // API 호출
      searchProjects(value);
    }, 300), // 300ms 대기
    []
  );
  
  const handleChange = (e) => {
    const value = e.target.value;
    setQuery(value);
    debouncedSearch(value);
  };
  
  return <input value={query} onChange={handleChange} />;
};

// 스크롤 이벤트 쓰로틀링
import { throttle } from 'lodash';

const InfiniteScroll = () => {
  const handleScroll = useCallback(
    throttle(() => {
      const { scrollTop, scrollHeight, clientHeight } = document.documentElement;
      if (scrollTop + clientHeight >= scrollHeight - 100) {
        loadMore();
      }
    }, 200), // 200ms마다 최대 1회 실행
    []
  );
  
  useEffect(() => {
    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, [handleScroll]);
};
```

### 7.5. 성능 모니터링 및 측정

#### 7.5.1. Lighthouse CI 통합

```yaml
# .github/workflows/lighthouse.yml
name: Lighthouse CI

on:
  pull_request:
    branches: [main]

jobs:
  lighthouse:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Run Lighthouse CI
        uses: treosh/lighthouse-ci-action@v10
        with:
          urls: |
            https://staging.mediaweave.ajou.ac.kr
            https://staging.mediaweave.ajou.ac.kr/curriculum/planner
            https://staging.mediaweave.ajou.ac.kr/community/projects
          uploadArtifacts: true
          temporaryPublicStorage: true
          
          # 성능 임계값
          budgetPath: ./lighthouse-budget.json
```

**lighthouse-budget.json**

```json
{
  "performance": 90,
  "accessibility": 95,
  "best-practices": 90,
  "seo": 95,
  "pwa": 80
}
```

#### 7.5.2. 성능 목표 및 측정

| 메트릭 | 목표 | 측정 도구 |
|--------|------|----------|
| **First Contentful Paint (FCP)** | < 1.5s | Lighthouse, Web Vitals |
| **Largest Contentful Paint (LCP)** | < 2.5s | Lighthouse, Web Vitals |
| **First Input Delay (FID)** | < 100ms | Web Vitals |
| **Cumulative Layout Shift (CLS)** | < 0.1 | Web Vitals |
| **Time to Interactive (TTI)** | < 3.5s | Lighthouse |
| **Total Blocking Time (TBT)** | < 300ms | Lighthouse |
| **번들 크기 (초기 로드)** | < 200KB (gzip) | Bundlephobia |
| **API 응답 시간 (P95)** | < 200ms | CloudWatch |

### 7.6. 성능 최적화 체크리스트

**Frontend**
- [ ] Code splitting 적용 (라우트별)
- [ ] 이미지 WebP 변환 및 Lazy Loading
- [ ] React Query 캐싱 설정
- [ ] 번들 크기 < 200KB (gzip)
- [ ] Lighthouse 점수 > 90

**Backend**
- [ ] Redis 캐싱 적용
- [ ] N+1 쿼리 제거
- [ ] 데이터베이스 인덱스 최적화
- [ ] Connection Pool 설정
- [ ] API 응답 시간 < 200ms (P95)

**Infrastructure**
- [ ] CloudFront CDN 설정
- [ ] S3 이미지 최적화
- [ ] Gzip 압축 활성화
- [ ] HTTP/2 활성화

---

## 8. 모니터링 및 로깅 (Monitoring & Logging)

### 8.1. 핵심 메트릭 정의

#### 8.1.1. 인프라 메트릭

**EC2 (Backend Server)**

| 메트릭 | 정상 범위 | 경고 임계값 | 위험 임계값 | 수집 주기 |
|--------|----------|------------|------------|----------|
| **CPU 사용률** | < 60% | 70% | 85% | 1분 |
| **메모리 사용률** | < 70% | 80% | 90% | 1분 |
| **디스크 사용률** | < 70% | 80% | 90% | 5분 |
| **네트워크 In/Out** | < 100 Mbps | 150 Mbps | 200 Mbps | 1분 |
| **디스크 I/O** | < 1000 IOPS | 1500 IOPS | 2000 IOPS | 1분 |

**RDS (PostgreSQL)**

| 메트릭 | 정상 범위 | 경고 임계값 | 위험 임계값 | 수집 주기 |
|--------|----------|------------|------------|----------|
| **CPU 사용률** | < 50% | 60% | 75% | 1분 |
| **메모리 여유 공간** | > 500 MB | < 300 MB | < 100 MB | 1분 |
| **스토리지 여유 공간** | > 20% | < 15% | < 10% | 5분 |
| **DB 연결 수** | < 50 | 70 | 90 | 1분 |
| **읽기 지연시간** | < 10 ms | 20 ms | 50 ms | 1분 |
| **쓰기 지연시간** | < 20 ms | 50 ms | 100 ms | 1분 |

**MongoDB Atlas**

| 메트릭 | 정상 범위 | 경고 임계값 | 위험 임계값 | 수집 주기 |
|--------|----------|------------|------------|----------|
| **연결 수** | < 100 | 150 | 200 | 1분 |
| **쿼리 실행 시간** | < 100 ms | 200 ms | 500 ms | 1분 |
| **디스크 사용률** | < 60% | 75% | 85% | 5분 |

#### 8.1.2. 애플리케이션 메트릭

**API 성능**

| 메트릭 | 정상 범위 | 경고 임계값 | 위험 임계값 | 측정 방법 |
|--------|----------|------------|------------|----------|
| **응답 시간 (P50)** | < 100 ms | 150 ms | 200 ms | CloudWatch Logs Insights |
| **응답 시간 (P95)** | < 200 ms | 300 ms | 500 ms | CloudWatch Logs Insights |
| **응답 시간 (P99)** | < 500 ms | 1000 ms | 2000 ms | CloudWatch Logs Insights |
| **처리량 (TPS)** | 10-100 | - | - | CloudWatch Metrics |
| **에러율** | < 0.1% | 1% | 5% | CloudWatch Logs |
| **가용성** | > 99.9% | < 99.5% | < 99% | Uptime 모니터링 |

**비즈니스 메트릭**

| 메트릭 | 측정 항목 | 수집 방법 |
|--------|----------|----------|
| **일일 활성 사용자 (DAU)** | 로그인 사용자 수 | MongoDB ActivityLog |
| **커리큘럼 생성 건수** | 일/주/월별 생성 수 | MongoDB Curriculum 집계 |
| **프로젝트 등록 건수** | 일/주/월별 등록 수 | PostgreSQL Projects 집계 |
| **평균 세션 시간** | 사용자별 체류 시간 | Google Analytics |
| **페이지 로드 시간** | 페이지별 로딩 시간 | Web Vitals (LCP, FID, CLS) |

#### 8.1.3. 사용자 경험 메트릭 (Web Vitals)

```javascript
// Frontend에서 Web Vitals 수집
import { getCLS, getFID, getLCP } from 'web-vitals';

const sendToAnalytics = (metric) => {
  const body = JSON.stringify({
    name: metric.name,
    value: metric.value,
    id: metric.id,
    page: window.location.pathname,
  });
  
  navigator.sendBeacon('/api/analytics/vitals', body);
};

getCLS(sendToAnalytics);  // Cumulative Layout Shift (< 0.1)
getFID(sendToAnalytics);  // First Input Delay (< 100ms)
getLCP(sendToAnalytics);  // Largest Contentful Paint (< 2.5s)
```

### 8.2. 알람 임계값 설정

#### 8.2.1. CloudWatch 알람 구성

**EC2 CPU 알람**

```bash
aws cloudwatch put-metric-alarm \
  --alarm-name mediaweave-api-cpu-high \
  --alarm-description "EC2 CPU usage exceeds 85%" \
  --metric-name CPUUtilization \
  --namespace AWS/EC2 \
  --statistic Average \
  --period 300 \
  --threshold 85 \
  --comparison-operator GreaterThanThreshold \
  --evaluation-periods 2 \
  --datapoints-to-alarm 2 \
  --alarm-actions arn:aws:sns:ap-northeast-2:123456789012:mediaweave-alerts
```

**RDS 연결 수 알람**

```bash
aws cloudwatch put-metric-alarm \
  --alarm-name mediaweave-db-connections-high \
  --alarm-description "RDS connections exceed 70" \
  --metric-name DatabaseConnections \
  --namespace AWS/RDS \
  --statistic Average \
  --period 60 \
  --threshold 70 \
  --comparison-operator GreaterThanThreshold \
  --evaluation-periods 3 \
  --alarm-actions arn:aws:sns:ap-northeast-2:123456789012:mediaweave-alerts
```

**API 에러율 알람**

```javascript
// CloudWatch Logs Insights 쿼리
fields @timestamp, @message, level, error
| filter level = "error"
| stats count() as errorCount by bin(5m)
| filter errorCount > 10

// Metric Filter 생성
aws logs put-metric-filter \
  --log-group-name /aws/ec2/mediaweave-api \
  --filter-name ErrorCount \
  --filter-pattern '[level=ERROR]' \
  --metric-transformations \
    metricName=ErrorCount,metricNamespace=MediaWeave,metricValue=1
```

#### 8.2.2. 알람 우선순위 및 대응

| 우선순위 | 조건 | 알림 채널 | 대응 시간 | 담당자 |
|---------|------|----------|----------|--------|
| **P0 (긴급)** | 서비스 다운, 에러율 > 5% | SMS + Slack + Email | 즉시 (15분 이내) | On-call 엔지니어 |
| **P1 (높음)** | CPU > 85%, 메모리 > 90% | Slack + Email | 1시간 이내 | 백엔드 팀 |
| **P2 (중간)** | 응답시간 > 500ms (P95) | Slack | 4시간 이내 | 백엔드 팀 |
| **P3 (낮음)** | 디스크 > 80% | Email | 1일 이내 | DevOps 팀 |

#### 8.2.3. SNS 알림 설정

```bash
# SNS Topic 생성
aws sns create-topic --name mediaweave-alerts

# Email 구독
aws sns subscribe \
  --topic-arn arn:aws:sns:ap-northeast-2:123456789012:mediaweave-alerts \
  --protocol email \
  --notification-endpoint devops@ajou.ac.kr

# Slack 웹훅 구독 (Lambda 함수 사용)
aws sns subscribe \
  --topic-arn arn:aws:sns:ap-northeast-2:123456789012:mediaweave-alerts \
  --protocol lambda \
  --notification-endpoint arn:aws:lambda:ap-northeast-2:123456789012:function:slack-notifier
```

### 8.3. 로그 수집 및 분석 전략

#### 8.3.1. 로그 레벨 정의

```javascript
// Winston 로거 설정
const winston = require('winston');
const { format } = winston;

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: format.combine(
    format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
    format.errors({ stack: true }),
    format.splat(),
    format.json()
  ),
  defaultMeta: {
    service: 'mediaweave-api',
    environment: process.env.NODE_ENV,
    version: process.env.APP_VERSION,
  },
  transports: [
    // Error 로그 (별도 파일)
    new winston.transports.File({
      filename: 'logs/error.log',
      level: 'error',
      maxsize: 10485760, // 10MB
      maxFiles: 30,
    }),
    
    // 전체 로그
    new winston.transports.File({
      filename: 'logs/combined.log',
      maxsize: 10485760,
      maxFiles: 7,
    }),
    
    // CloudWatch Logs (Production)
    ...(process.env.NODE_ENV === 'production' ? [
      new WinstonCloudWatch({
        logGroupName: '/aws/ec2/mediaweave-api',
        logStreamName: `${process.env.NODE_ENV}-${new Date().toISOString().split('T')[0]}`,
        awsRegion: 'ap-northeast-2',
      })
    ] : []),
  ],
});

// Development 환경에서는 콘솔 출력
if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: format.combine(
      format.colorize(),
      format.simple()
    ),
  }));
}

module.exports = logger;
```

**로그 레벨 사용 가이드**

| 레벨 | 용도 | 예시 |
|------|------|------|
| **error** | 시스템 오류, 예외 발생 | DB 연결 실패, API 호출 실패 |
| **warn** | 잠재적 문제, 비정상 상태 | 느린 쿼리, 높은 메모리 사용 |
| **info** | 주요 이벤트, 비즈니스 로직 | 사용자 로그인, 프로젝트 생성 |
| **http** | HTTP 요청/응답 | API 호출 로그 |
| **debug** | 디버깅 정보 | 변수 값, 함수 호출 |

#### 8.3.2. 구조화된 로그 포맷

```javascript
// 요청 로그
logger.info('API request', {
  method: req.method,
  path: req.path,
  userId: req.user?.id,
  ip: req.ip,
  userAgent: req.get('user-agent'),
  requestId: req.id,
});

// 응답 로그
logger.info('API response', {
  method: req.method,
  path: req.path,
  statusCode: res.statusCode,
  responseTime: Date.now() - req.startTime,
  requestId: req.id,
});

// 에러 로그
logger.error('Database query failed', {
  error: err.message,
  stack: err.stack,
  query: sanitizedQuery,
  userId: req.user?.id,
  requestId: req.id,
});

// 비즈니스 이벤트 로그
logger.info('Curriculum created', {
  userId: user.id,
  curriculumId: curriculum._id,
  semesterCount: Object.keys(curriculum.semesters).length,
  totalCredits: calculateTotalCredits(curriculum),
});
```

#### 8.3.3. CloudWatch Logs Insights 쿼리

**에러 분석**

```sql
-- 시간대별 에러 발생 건수
fields @timestamp, level, error.message
| filter level = "error"
| stats count() as errorCount by bin(1h)
| sort @timestamp desc

-- 가장 많이 발생한 에러 Top 10
fields error.message
| filter level = "error"
| stats count() as count by error.message
| sort count desc
| limit 10

-- 특정 사용자의 에러 추적
fields @timestamp, method, path, error.message, error.stack
| filter userId = "user123" and level = "error"
| sort @timestamp desc
```

**성능 분석**

```sql
-- 느린 API 엔드포인트 (P95 > 500ms)
fields path, responseTime
| filter responseTime > 500
| stats count() as slowRequests, avg(responseTime) as avgTime, 
        pct(responseTime, 95) as p95 by path
| sort slowRequests desc

-- 시간대별 평균 응답 시간
fields @timestamp, responseTime
| stats avg(responseTime) as avgResponseTime by bin(5m)
| sort @timestamp desc
```

**사용자 활동 분석**

```sql
-- 일일 활성 사용자 (DAU)
fields userId
| filter method = "GET" or method = "POST"
| stats count_distinct(userId) as dau by bin(1d)

-- 인기 API 엔드포인트
fields path, method
| stats count() as requestCount by path, method
| sort requestCount desc
| limit 20
```

#### 8.3.4. 로그 보관 정책

| 로그 유형 | 보관 기간 | 저장 위치 | 압축 |
|----------|----------|----------|------|
| **Error 로그** | 90일 | CloudWatch Logs | Gzip |
| **Access 로그** | 30일 | CloudWatch Logs | Gzip |
| **Audit 로그** | 1년 | S3 Glacier | Gzip |
| **Debug 로그** | 7일 | 로컬 파일 | - |

```bash
# CloudWatch Logs 보관 정책 설정
aws logs put-retention-policy \
  --log-group-name /aws/ec2/mediaweave-api \
  --retention-in-days 30

# S3로 자동 아카이빙 (Lambda 함수)
aws logs create-export-task \
  --log-group-name /aws/ec2/mediaweave-api \
  --from $(date -d '30 days ago' +%s)000 \
  --to $(date +%s)000 \
  --destination s3://mediaweave-logs-archive
```

### 8.4. 모니터링 대시보드

#### 8.4.1. CloudWatch 대시보드 구성

```json
{
  "widgets": [
    {
      "type": "metric",
      "properties": {
        "title": "API Response Time (P95)",
        "metrics": [
          ["MediaWeave", "ResponseTime", { "stat": "p95" }]
        ],
        "period": 300,
        "region": "ap-northeast-2",
        "yAxis": { "left": { "min": 0, "max": 1000 } }
      }
    },
    {
      "type": "metric",
      "properties": {
        "title": "Error Rate",
        "metrics": [
          ["MediaWeave", "ErrorCount", { "stat": "Sum" }]
        ],
        "period": 300,
        "region": "ap-northeast-2"
      }
    },
    {
      "type": "metric",
      "properties": {
        "title": "EC2 CPU & Memory",
        "metrics": [
          ["AWS/EC2", "CPUUtilization", { "stat": "Average" }],
          ["CWAgent", "mem_used_percent", { "stat": "Average" }]
        ],
        "period": 60,
        "region": "ap-northeast-2"
      }
    },
    {
      "type": "metric",
      "properties": {
        "title": "RDS Connections",
        "metrics": [
          ["AWS/RDS", "DatabaseConnections", { "stat": "Average" }]
        ],
        "period": 60,
        "region": "ap-northeast-2"
      }
    },
    {
      "type": "log",
      "properties": {
        "title": "Recent Errors",
        "query": "SOURCE '/aws/ec2/mediaweave-api' | fields @timestamp, error.message | filter level = 'error' | sort @timestamp desc | limit 20",
        "region": "ap-northeast-2"
      }
    }
  ]
}
```

#### 8.4.2. Grafana 대시보드 (선택사항)

```yaml
# Prometheus + Grafana 구성
# docker-compose.yml
version: '3.8'
services:
  prometheus:
    image: prom/prometheus:latest
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
    ports:
      - "9090:9090"
  
  grafana:
    image: grafana/grafana:latest
    ports:
      - "3001:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - grafana-storage:/var/lib/grafana

volumes:
  grafana-storage:
```

### 8.5. 에러 트래킹 (Sentry)

```javascript
// Frontend (React)
import * as Sentry from "@sentry/react";

Sentry.init({
  dsn: import.meta.env.VITE_SENTRY_DSN,
  environment: import.meta.env.VITE_ENV,
  tracesSampleRate: 0.1, // 10% 트랜잭션 샘플링
  replaysSessionSampleRate: 0.1,
  replaysOnErrorSampleRate: 1.0,
  integrations: [
    new Sentry.BrowserTracing(),
    new Sentry.Replay(),
  ],
});

// Backend (Node.js)
const Sentry = require("@sentry/node");

Sentry.init({
  dsn: process.env.SENTRY_DSN,
  environment: process.env.NODE_ENV,
  tracesSampleRate: 0.1,
});

// Express 미들웨어
app.use(Sentry.Handlers.requestHandler());
app.use(Sentry.Handlers.tracingHandler());

// 에러 핸들러 (마지막에 추가)
app.use(Sentry.Handlers.errorHandler());
```

### 8.6. 모니터링 체크리스트

**일일 점검**
- [ ] CloudWatch 대시보드 확인
- [ ] 에러 로그 검토 (P0/P1 알람)
- [ ] API 응답 시간 추이 확인
- [ ] 데이터베이스 성능 확인

**주간 점검**
- [ ] 디스크 사용량 확인
- [ ] 로그 보관 정책 검토
- [ ] 비정상 트래픽 패턴 분석
- [ ] 성능 병목 지점 식별

**월간 점검**
- [ ] 인프라 비용 분석
- [ ] 용량 계획 (Capacity Planning)
- [ ] 보안 취약점 스캔
- [ ] 백업 복구 테스트

---

## 9. 확장성 시나리오 (Scalability Scenarios)

### 9.1. 현재 용량 및 예상 성장

#### 9.1.1. 초기 용량 계획 (MVP)

| 리소스 | 현재 사양 | 예상 부하 | 여유율 |
|--------|----------|----------|--------|
| **사용자 수** | 500명 | 동시 접속 50명 | 10배 |
| **API 요청** | 10 TPS | 피크 시 30 TPS | 3배 |
| **데이터베이스** | 10GB | 월 1GB 증가 | 10개월 |
| **스토리지** | 50GB | 월 5GB 증가 | 10개월 |
| **대역폭** | 100GB/월 | 피크 시 200GB/월 | 2배 |

#### 9.1.2. 성장 시나리오

**시나리오 1: 학기 시작 (트래픽 3배 증가)**

```
현재: 동시 접속 50명, 10 TPS
예상: 동시 접속 150명, 30 TPS

트리거 조건:
- CPU 사용률 > 70% (5분 이상)
- API 응답 시간 > 300ms (P95)
- 데이터베이스 연결 수 > 70

대응 방안:
1. EC2 Auto Scaling 자동 확장 (1대 → 2대)
2. Redis 캐시 TTL 연장 (5분 → 30분)
3. RDS Read Replica 추가 (읽기 부하 분산)
```

**시나리오 2: 전체 학생 사용 (트래픽 10배 증가)**

```
현재: 동시 접속 50명, 10 TPS
예상: 동시 접속 500명, 100 TPS

트리거 조건:
- 사용자 수 > 3,000명
- 일일 활성 사용자 (DAU) > 1,000명
- API 요청 > 80 TPS

대응 방안:
1. EC2 인스턴스 타입 업그레이드 (t3.medium → t3.large)
2. EC2 Auto Scaling 최대 인스턴스 수 증가 (2대 → 4대)
3. RDS 인스턴스 타입 업그레이드 (db.t3.small → db.t3.medium)
4. ElastiCache Redis 도입 (캐싱 강화)
5. CloudFront 캐시 정책 최적화
```

**시나리오 3: 타 대학 확장 (트래픽 50배 증가)**

```
현재: 동시 접속 50명, 10 TPS
예상: 동시 접속 2,500명, 500 TPS

트리거 조건:
- 사용자 수 > 10,000명
- 일일 활성 사용자 (DAU) > 3,000명
- API 요청 > 400 TPS

대응 방안:
1. 마이크로서비스 아키텍처 전환
2. Kubernetes (EKS) 도입
3. RDS Aurora 전환 (자동 스케일링)
4. MongoDB Atlas M30 이상 (샤딩)
5. CDN 멀티 리전 배포
6. API Gateway + Lambda (서버리스 전환 검토)
```

### 9.2. 수평 확장 (Horizontal Scaling)

#### 9.2.1. EC2 Auto Scaling 설정

```bash
# Launch Template 생성
aws ec2 create-launch-template \
  --launch-template-name mediaweave-api-template \
  --version-description "v1.0" \
  --launch-template-data '{
    "ImageId": "ami-0c55b159cbfafe1f0",
    "InstanceType": "t3.medium",
    "KeyName": "mediaweave-key",
    "SecurityGroupIds": ["sg-0123456789abcdef0"],
    "UserData": "IyEvYmluL2Jhc2gKY2QgL2hvbWUvdWJ1bnR1L21lZGlhd2VhdmUtYXBpCmdpdCBwdWxsCm5wbSBjaQpwbTIgcmVsb2FkIGVjb3N5c3RlbS5jb25maWcuanMgLS1lbnYgcHJvZHVjdGlvbg=="
  }'

# Auto Scaling Group 생성
aws autoscaling create-auto-scaling-group \
  --auto-scaling-group-name mediaweave-api-asg \
  --launch-template LaunchTemplateName=mediaweave-api-template,Version='$Latest' \
  --min-size 2 \
  --max-size 8 \
  --desired-capacity 2 \
  --target-group-arns arn:aws:elasticloadbalancing:ap-northeast-2:123456789012:targetgroup/mediaweave-api/abc123 \
  --health-check-type ELB \
  --health-check-grace-period 300 \
  --vpc-zone-identifier "subnet-12345,subnet-67890"

# Scaling Policy 생성 (CPU 기반)
aws autoscaling put-scaling-policy \
  --auto-scaling-group-name mediaweave-api-asg \
  --policy-name cpu-scale-out \
  --policy-type TargetTrackingScaling \
  --target-tracking-configuration '{
    "PredefinedMetricSpecification": {
      "PredefinedMetricType": "ASGAverageCPUUtilization"
    },
    "TargetValue": 70.0
  }'

# Scaling Policy 생성 (요청 수 기반)
aws autoscaling put-scaling-policy \
  --auto-scaling-group-name mediaweave-api-asg \
  --policy-name request-count-scale-out \
  --policy-type TargetTrackingScaling \
  --target-tracking-configuration '{
    "PredefinedMetricSpecification": {
      "PredefinedMetricType": "ALBRequestCountPerTarget",
      "ResourceLabel": "app/mediaweave-alb/abc123/targetgroup/mediaweave-api/def456"
    },
    "TargetValue": 1000.0
  }'
```

#### 9.2.2. Application Load Balancer 설정

```bash
# ALB 생성
aws elbv2 create-load-balancer \
  --name mediaweave-alb \
  --subnets subnet-12345 subnet-67890 \
  --security-groups sg-0123456789abcdef0 \
  --scheme internet-facing \
  --type application \
  --ip-address-type ipv4

# Target Group 생성
aws elbv2 create-target-group \
  --name mediaweave-api-tg \
  --protocol HTTP \
  --port 3000 \
  --vpc-id vpc-12345 \
  --health-check-enabled \
  --health-check-protocol HTTP \
  --health-check-path /health \
  --health-check-interval-seconds 30 \
  --health-check-timeout-seconds 5 \
  --healthy-threshold-count 2 \
  --unhealthy-threshold-count 3

# Listener 생성 (HTTPS)
aws elbv2 create-listener \
  --load-balancer-arn arn:aws:elasticloadbalancing:ap-northeast-2:123456789012:loadbalancer/app/mediaweave-alb/abc123 \
  --protocol HTTPS \
  --port 443 \
  --certificates CertificateArn=arn:aws:acm:ap-northeast-2:123456789012:certificate/xyz789 \
  --default-actions Type=forward,TargetGroupArn=arn:aws:elasticloadbalancing:ap-northeast-2:123456789012:targetgroup/mediaweave-api-tg/def456

# Sticky Session 설정
aws elbv2 modify-target-group-attributes \
  --target-group-arn arn:aws:elasticloadbalancing:ap-northeast-2:123456789012:targetgroup/mediaweave-api-tg/def456 \
  --attributes Key=stickiness.enabled,Value=true Key=stickiness.type,Value=lb_cookie Key=stickiness.lb_cookie.duration_seconds,Value=86400
```

#### 9.2.3. RDS Read Replica 추가

```bash
# Read Replica 생성
aws rds create-db-instance-read-replica \
  --db-instance-identifier mediaweave-db-read-replica-1 \
  --source-db-instance-identifier mediaweave-db-prod \
  --db-instance-class db.t3.small \
  --availability-zone ap-northeast-2a \
  --publicly-accessible false

# 읽기 전용 엔드포인트 사용
const readPool = new Sequelize(database, username, password, {
  host: 'mediaweave-db-read-replica-1.xxxxx.ap-northeast-2.rds.amazonaws.com',
  dialect: 'postgres',
  pool: { max: 10, min: 2 },
});

const writePool = new Sequelize(database, username, password, {
  host: 'mediaweave-db-prod.xxxxx.ap-northeast-2.rds.amazonaws.com',
  dialect: 'postgres',
  pool: { max: 20, min: 5 },
});

// 읽기/쓰기 분리
const getProjects = async () => {
  return readPool.query('SELECT * FROM projects ORDER BY created_at DESC LIMIT 20');
};

const createProject = async (data) => {
  return writePool.query('INSERT INTO projects (...) VALUES (...)');
};
```

### 9.3. 수직 확장 (Vertical Scaling)

#### 9.3.1. 인스턴스 타입 업그레이드 경로

**EC2 Backend Server**

| 단계 | 인스턴스 타입 | vCPU | 메모리 | 예상 부하 | 월 비용 (서울) |
|------|--------------|------|--------|----------|---------------|
| **1단계 (MVP)** | t3.small | 2 | 2GB | 50 동시 접속 | $15 |
| **2단계** | t3.medium | 2 | 4GB | 150 동시 접속 | $30 |
| **3단계** | t3.large | 2 | 8GB | 500 동시 접속 | $60 |
| **4단계** | c6i.xlarge | 4 | 8GB | 1,000 동시 접속 | $120 |
| **5단계** | c6i.2xlarge | 8 | 16GB | 2,500 동시 접속 | $240 |

**RDS PostgreSQL**

| 단계 | 인스턴스 타입 | vCPU | 메모리 | 스토리지 | 예상 부하 | 월 비용 |
|------|--------------|------|--------|----------|----------|---------|
| **1단계 (MVP)** | db.t3.micro | 2 | 1GB | 20GB | 10 TPS | $15 |
| **2단계** | db.t3.small | 2 | 2GB | 50GB | 30 TPS | $35 |
| **3단계** | db.t3.medium | 2 | 4GB | 100GB | 100 TPS | $70 |
| **4단계** | db.r6i.large | 2 | 16GB | 200GB | 300 TPS | $200 |
| **5단계** | Aurora Serverless v2 | Auto | Auto | Auto | 500+ TPS | $150-500 |

#### 9.3.2. 무중단 인스턴스 타입 변경

```bash
# EC2 인스턴스 타입 변경 (Auto Scaling Group)
# 1. Launch Template 업데이트
aws ec2 create-launch-template-version \
  --launch-template-name mediaweave-api-template \
  --source-version 1 \
  --launch-template-data '{"InstanceType": "t3.large"}'

# 2. Auto Scaling Group 업데이트
aws autoscaling update-auto-scaling-group \
  --auto-scaling-group-name mediaweave-api-asg \
  --launch-template LaunchTemplateName=mediaweave-api-template,Version='$Latest'

# 3. 인스턴스 교체 (Rolling Update)
aws autoscaling start-instance-refresh \
  --auto-scaling-group-name mediaweave-api-asg \
  --preferences MinHealthyPercentage=50,InstanceWarmup=300

# RDS 인스턴스 타입 변경 (다운타임 발생)
aws rds modify-db-instance \
  --db-instance-identifier mediaweave-db-prod \
  --db-instance-class db.t3.medium \
  --apply-immediately
```

### 9.4. 데이터베이스 확장 전략

#### 9.4.1. PostgreSQL 확장 옵션

**옵션 1: RDS Read Replica (읽기 부하 분산)**

```
┌─────────────┐
│   Client    │
└──────┬──────┘
       │
┌──────▼──────────────────────────┐
│      Application Server         │
│  ┌──────────────────────────┐   │
│  │  Write → Master DB       │   │
│  │  Read  → Read Replica    │   │
│  └──────────────────────────┘   │
└─────────────────────────────────┘
       │              │
       ↓              ↓
┌─────────────┐  ┌─────────────┐
│  Master DB  │→→│Read Replica │
│   (Write)   │  │   (Read)    │
└─────────────┘  └─────────────┘
```

**옵션 2: Aurora Serverless v2 (자동 스케일링)**

```javascript
// Aurora Serverless v2 설정
const sequelize = new Sequelize(database, username, password, {
  host: 'mediaweave-aurora-cluster.cluster-xxxxx.ap-northeast-2.rds.amazonaws.com',
  dialect: 'postgres',
  dialectOptions: {
    ssl: {
      require: true,
      rejectUnauthorized: false,
    },
  },
});

// 자동 스케일링 설정
// Min ACU: 0.5 (1GB RAM)
// Max ACU: 16 (32GB RAM)
// 부하에 따라 자동으로 스케일 업/다운
```

**옵션 3: 샤딩 (데이터 분산)**

```javascript
// 사용자 ID 기반 샤딩
const getShardId = (userId) => {
  return userId % 4; // 4개 샤드
};

const getConnection = (userId) => {
  const shardId = getShardId(userId);
  return shardConnections[shardId];
};

// 사용 예시
const user = await getConnection(userId).query('SELECT * FROM users WHERE id = ?', [userId]);
```

#### 9.4.2. MongoDB 확장 옵션

**옵션 1: Atlas Auto-Scaling**

```javascript
// MongoDB Atlas M10 → M30 자동 스케일링
// 설정: Atlas Console → Cluster → Auto-Scale Cluster Tier
// Min: M10 (2GB RAM)
// Max: M30 (8GB RAM)
```

**옵션 2: 샤딩 (Horizontal Partitioning)**

```javascript
// Shard Key 설정 (user_id 기반)
db.curriculums.createIndex({ user_id: 1 });
sh.shardCollection("mediaweave.curriculums", { user_id: 1 });

// 3개 샤드로 데이터 분산
// Shard 1: user_id 0-333
// Shard 2: user_id 334-666
// Shard 3: user_id 667-999
```

### 9.5. 마이크로서비스 전환 계획

#### 9.5.1. 서비스 분리 전략

```
현재 (Monolithic):
┌─────────────────────────────────┐
│      Single API Server          │
│  - Auth                         │
│  - Curriculum                   │
│  - Projects                     │
│  - Team Building                │
└─────────────────────────────────┘

향후 (Microservices):
┌─────────────────────────────────┐
│       API Gateway               │
└──┬────────┬────────┬────────┬───┘
   │        │        │        │
   ↓        ↓        ↓        ↓
┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐
│ Auth │ │Curri-│ │Proj- │ │Team  │
│Service│ │culum │ │ects  │ │Build │
└──────┘ └──────┘ └──────┘ └──────┘
```

#### 9.5.2. 서비스 분리 우선순위

| 우선순위 | 서비스 | 분리 이유 | 예상 시기 |
|---------|--------|----------|----------|
| **1** | **Projects Service** | 독립적 기능, 높은 트래픽 | 사용자 5,000명 이상 |
| **2** | **Team Building Service** | 독립적 기능, 실시간 기능 필요 | 사용자 10,000명 이상 |
| **3** | **Curriculum Service** | 복잡한 비즈니스 로직 | 사용자 20,000명 이상 |
| **4** | **Auth Service** | 보안 강화 필요 | 타 대학 확장 시 |

### 9.6. 비용 최적화 전략

#### 9.6.1. 단계별 예상 비용

| 단계 | 사용자 수 | 월 비용 | 주요 비용 항목 |
|------|----------|---------|---------------|
| **MVP** | 500명 | $50 | EC2 t3.small, RDS db.t3.micro, S3 |
| **1단계** | 3,000명 | $150 | EC2 t3.medium x2, RDS db.t3.small, Redis |
| **2단계** | 10,000명 | $500 | EC2 t3.large x4, RDS db.t3.medium, CloudFront |
| **3단계** | 50,000명 | $2,000 | EKS, Aurora, ElastiCache, Multi-AZ |

#### 9.6.2. 비용 절감 방안

```bash
# Reserved Instances (1년 약정 시 40% 할인)
aws ec2 purchase-reserved-instances-offering \
  --reserved-instances-offering-id abc-123 \
  --instance-count 2

# Savings Plans (유연한 약정 옵션)
aws savingsplans create-savings-plan \
  --savings-plan-type Compute \
  --commitment 100 \
  --upfront-payment-amount 0

# S3 Lifecycle Policy (오래된 파일 자동 삭제)
aws s3api put-bucket-lifecycle-configuration \
  --bucket mediaweave-uploads \
  --lifecycle-configuration '{
    "Rules": [{
      "Id": "DeleteOldFiles",
      "Status": "Enabled",
      "Expiration": { "Days": 365 },
      "Transitions": [{
        "Days": 90,
        "StorageClass": "GLACIER"
      }]
    }]
  }'
```

### 9.7. 확장성 테스트

#### 9.7.1. 부하 테스트 (k6)

```javascript
// load-test.js
import http from 'k6/http';
import { check, sleep } from 'k6';

export const options = {
  stages: [
    { duration: '2m', target: 100 },  // Ramp up to 100 users
    { duration: '5m', target: 100 },  // Stay at 100 users
    { duration: '2m', target: 200 },  // Ramp up to 200 users
    { duration: '5m', target: 200 },  // Stay at 200 users
    { duration: '2m', target: 0 },    // Ramp down to 0 users
  ],
  thresholds: {
    http_req_duration: ['p(95)<500'], // 95% of requests must complete below 500ms
    http_req_failed: ['rate<0.01'],   // Error rate must be below 1%
  },
};

export default function () {
  const res = http.get('https://api.mediaweave.ajou.ac.kr/api/projects');
  
  check(res, {
    'status is 200': (r) => r.status === 200,
    'response time < 500ms': (r) => r.timings.duration < 500,
  });
  
  sleep(1);
}
```

```bash
# 부하 테스트 실행
k6 run load-test.js

# 결과 예시
# ✓ status is 200
# ✓ response time < 500ms
# 
# checks.........................: 100.00% ✓ 12000 ✗ 0
# data_received..................: 24 MB   80 kB/s
# data_sent......................: 1.2 MB  4.0 kB/s
# http_req_duration..............: avg=245ms min=120ms med=230ms max=480ms p(95)=380ms
# http_reqs......................: 12000   40/s
```

### 9.8. 확장성 체크리스트

**인프라**
- [ ] Auto Scaling Group 설정 완료
- [ ] Load Balancer Health Check 설정
- [ ] RDS Read Replica 준비
- [ ] Redis 캐싱 적용
- [ ] CloudFront CDN 설정

**모니터링**
- [ ] CPU/메모리 알람 설정
- [ ] API 응답 시간 모니터링
- [ ] 데이터베이스 연결 수 모니터링
- [ ] 비용 알람 설정

**테스트**
- [ ] 부하 테스트 완료 (k6)
- [ ] 스케일 아웃 테스트 완료
- [ ] 장애 복구 테스트 완료
- [ ] 롤백 테스트 완료

---

## 10. 개발 환경 (Development Environment)

### 10.1. 로컬 개발 설정

```bash
# Frontend
cd client
npm install
npm run dev  # http://localhost:5173

# Backend
cd server
npm install
npm run dev  # http://localhost:3000
```

### 10.2. Docker Compose (선택사항)

```yaml
version: '3.8'
services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: mediaweave
      POSTGRES_USER: admin
      POSTGRES_PASSWORD: password
    ports:
      - "5432:5432"
  
  mongodb:
    image: mongo:7
    ports:
      - "27017:27017"
  
  backend:
    build: ./server
    ports:
      - "3000:3000"
    depends_on:
      - postgres
      - mongodb
```

---

## 부록: 기술 선택 근거

| 기술 | 대안 | 선택 이유 |
|------|------|----------|
| **React** | Vue, Angular | 생태계 풍부, React Flow 라이브러리 활용 |
| **Vite** | CRA, Webpack | 빠른 HMR, 간단한 설정 |
| **PostgreSQL** | MySQL | 복잡한 관계 처리, JSON 타입 지원 |
| **MongoDB** | DynamoDB | 무료 Atlas 플랜, 학습 곡선 낮음 |
| **Express** | Nest.js, Fastify | 간단한 구조, 빠른 개발 |
| **AWS** | GCP, Azure | 국내 리전, 풍부한 학습 자료 |
